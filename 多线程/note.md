#全局解释锁，多线程
    -python运行由python虚拟机进行控制
    -在主循环中只能有一个控制线程执行
#案例一，顺序执行耗时长
#案例二，改用_thread
#案例三，多线程，传参数
-threading的使用
    -直接利用threading.Thread生产thread实例
        1.t=threading.Thread(target=xxx,args=(xxx,))
        2.t.start():启动多线程
        3.t.join():等待多线程执行完成
        4.案例04
        5.案例05 加入join跟案例4的比较
        -守护线程-daemon
            -如果在子线程中设置守护线程，则子线程会在主线程结束时自动退出
    -直接继承thread.threading 案例07
-共享变量
    -当多个线程同时访问一个变量的时候，会出现这个问题 案例08
    -解决变量：锁，信号灯
    -锁（lock）：
        -是一个标准，表示一个线程在占用一些资源
        -使用方法
            -上锁
            -使用共享资源，放心的用
            -取消锁，释放锁
        -案例12
    -线程安全问题：
        -如果一个变量/资源，他对于多个线程来讲，不用加锁也不会引起任何问题，则成为线程安全
        -线程不安全变量： list，set，dict
        -线程安全变量：queue（队列）
    -生产者消费者问题
        -一个模型，可以用来搭建消息队列 案例10
        -queue是一个用来存放变量的数据结构，先进先出
    -死锁问题 案例11
    -锁的等待时间问题 案例12
    -semphore 006
        -允许一个资源最多有几个多线程同时使用
        -案例13
    -可重入锁
        -一个锁可以被一个线程多次申请
        -主要解决递归函数调用的时候，需要申请锁的情况
        -案例14
    #线程替代方案
    -subprocess
        -完全跳过线程，使用进程
        -派生进程的主要替代方案
    -multiprocessing
        -使用threading接口派生，使用子进程
        -允许为多核或者多cpu派生进程，接口跟threading非常相似
#多进程
-进程间通讯(InterprocessCommunication,IPC)
-进程之间无共享状态
-进程的创建
    -直接生产process实例对象 案例15
    -p派生子类 案例16
-在os中查看pid，ppid(parent process父进程id)以及他们的关系
    案例17
-生产者消费者模型 案例18
   -JoinableQueue
   队列中哨兵的使用 案例19